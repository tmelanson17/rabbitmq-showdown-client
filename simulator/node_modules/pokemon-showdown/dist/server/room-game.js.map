{
  "version": 3,
  "sources": ["../../server/room-game.ts"],
  "sourcesContent": ["/**\n * Room games\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * Room games are an abstract representation of an activity that a room\n * can be focused on, such as a battle, tournament, or chat game like\n * Hangman. Rooms are limited to one roomgame at a time.\n *\n * Room games can keep track of designated players. If a user is a player,\n * they will not be allowed to change name until their games are complete.\n *\n * The player system is optional: Some games, like Hangman, don't designate\n * players and just allow any user in the room to play.\n *\n * @license MIT\n */\n\n// globally Rooms.RoomGamePlayer\nexport class RoomGamePlayer<GameClass extends RoomGame = SimpleRoomGame> {\n\treadonly num: number;\n\treadonly game: GameClass;\n\t/**\n\t * Will be the username of the user playing, but with some exceptions:\n\t *\n\t * - Creating a game with no users will initialize player names to\n\t *   \"Player 1\", \"Player 2\", etc.\n\t * - Players will retain the name of the last active user, even if that\n\t *   user abandons the game.\n\t */\n\tname: string;\n\t/**\n\t * This will be '' if there's no user associated with the player.\n\t *\n\t * we explicitly don't hold a direct reference to the user\n\t */\n\tid: ID;\n\tconstructor(user: User | string | null, game: GameClass, num = 0) {\n\t\tthis.num = num;\n\t\tif (!user) user = num ? `Player ${num}` : `Player`;\n\t\tthis.game = game;\n\t\tthis.name = (typeof user === 'string' ? user : user.name);\n\t\tif (typeof user === 'string') user = null;\n\t\tthis.id = user ? user.id : '';\n\t\tif (user && !this.game.isSubGame) {\n\t\t\tuser.games.add(this.game.roomid);\n\t\t\tuser.updateSearch();\n\t\t}\n\t}\n\tunlinkUser() {\n\t\tif (!this.id) return;\n\t\tconst user = Users.getExact(this.id);\n\t\tif (user && !this.game.isSubGame) {\n\t\t\tuser.games.delete(this.game.roomid);\n\t\t\tuser.updateSearch();\n\t\t}\n\t\tthis.id = '';\n\t}\n\tdestroy() {\n\t\tthis.unlinkUser();\n\t}\n\n\ttoString() {\n\t\treturn this.id;\n\t}\n\tsend(data: string) {\n\t\tconst user = Users.getExact(this.id);\n\t\tif (user) user.send(data);\n\t}\n\tsendRoom(data: string) {\n\t\tconst user = Users.getExact(this.id);\n\t\tif (user) user.sendTo(this.game.roomid, data);\n\t}\n}\n\n/**\n * globally Rooms.RoomGame\n *\n * If you don't want to define your own player class, you should extend SimpleRoomGame.\n */\nexport abstract class RoomGame<PlayerClass extends RoomGamePlayer = RoomGamePlayer> {\n\troomid: RoomID;\n\t/**\n\t * The room this roomgame is in. Rooms can have two RoomGames at a time,\n\t * which are available as `this.room.game === this` and `this.room.subGame === this`.\n\t */\n\troom: Room;\n\tgameid: ID;\n\ttitle: string;\n\tallowRenames: boolean;\n\tisSubGame: boolean;\n\t/**\n\t * userid:player table.\n\t *\n\t * Does not contain userless players: use playerList for the full list.\n\t */\n\tplayerTable: {[userid: string]: PlayerClass};\n\tplayers: PlayerClass[];\n\tplayerCount: number;\n\tplayerCap: number;\n\tended: boolean;\n\t/** Does `/guess` or `/choose` require the user to be able to talk? */\n\tcheckChat = false;\n\t/**\n\t * We should really resolve this collision at _some_ point, but it will have\n\t * to be later. The /timer command is written to be resilient to this.\n\t */\n\ttimer?: {timerRequesters?: Set<ID>, start: (force?: User) => void, stop: (force?: User) => void} | NodeJS.Timer | null;\n\tconstructor(room: Room, isSubGame = false) {\n\t\tthis.roomid = room.roomid;\n\t\tthis.room = room;\n\t\tthis.gameid = 'game' as ID;\n\t\tthis.title = 'Game';\n\t\tthis.allowRenames = false;\n\t\tthis.isSubGame = isSubGame;\n\t\tthis.playerTable = Object.create(null);\n\t\tthis.players = [];\n\t\tthis.playerCount = 0;\n\t\tthis.playerCap = 0;\n\t\tthis.ended = false;\n\n\t\tif (this.isSubGame) {\n\t\t\tthis.room.subGame = this;\n\t\t} else {\n\t\t\tthis.room.game = this;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.isSubGame) {\n\t\t\tthis.room.subGame = null;\n\t\t} else {\n\t\t\tthis.room.game = null;\n\t\t}\n\t\t// @ts-ignore\n\t\tthis.room = null;\n\t\tfor (const player of this.players) {\n\t\t\tplayer.destroy();\n\t\t}\n\t\t// @ts-ignore\n\t\tthis.players = null;\n\t\t// @ts-ignore\n\t\tthis.playerTable = null;\n\t}\n\n\taddPlayer(user: User | string | null = null, ...rest: any[]): PlayerClass | null {\n\t\tif (typeof user !== 'string' && user) {\n\t\t\tif (user.id in this.playerTable) return null;\n\t\t}\n\t\tif (this.playerCap > 0 && this.playerCount >= this.playerCap) return null;\n\t\tconst player = this.makePlayer(user, ...rest);\n\t\tif (!player) return null;\n\t\tif (typeof user === 'string') user = null;\n\t\tthis.players.push(player);\n\t\tif (user) {\n\t\t\tthis.playerTable[user.id] = player;\n\t\t\tthis.playerCount++;\n\t\t}\n\t\treturn player;\n\t}\n\n\tupdatePlayer(player: PlayerClass, user: User | null) {\n\t\tif (!this.allowRenames) return;\n\t\tif (player.id) {\n\t\t\tdelete this.playerTable[player.id];\n\t\t}\n\t\tif (user) {\n\t\t\tplayer.id = user.id;\n\t\t\tplayer.name = user.name;\n\t\t\tthis.playerTable[player.id] = player;\n\t\t\tthis.room.auth.set(user.id, Users.PLAYER_SYMBOL);\n\t\t} else {\n\t\t\tplayer.unlinkUser();\n\t\t}\n\t}\n\n\tabstract makePlayer(user: User | string | null, ...rest: any[]): PlayerClass;\n\n\tremovePlayer(player: PlayerClass | User) {\n\t\tif (player instanceof Users.User) {\n\t\t\t// API changed\n\t\t\t// TODO: deprecate\n\t\t\tplayer = this.playerTable[player.id];\n\t\t\tif (!player) throw new Error(\"Player not found\");\n\t\t}\n\t\tif (!this.allowRenames) return false;\n\t\tconst playerIndex = this.players.indexOf(player);\n\t\tif (playerIndex < 0) return false;\n\t\tif (player.id) delete this.playerTable[player.id];\n\t\tthis.players.splice(playerIndex, 1);\n\t\tplayer.destroy();\n\t\tthis.playerCount--;\n\t\treturn true;\n\t}\n\n\trenamePlayer(user: User, oldUserid: ID) {\n\t\tif (user.id === oldUserid) {\n\t\t\tthis.playerTable[user.id].name = user.name;\n\t\t} else {\n\t\t\tthis.playerTable[user.id] = this.playerTable[oldUserid];\n\t\t\tthis.playerTable[user.id].id = user.id;\n\t\t\tthis.playerTable[user.id].name = user.name;\n\t\t\tdelete this.playerTable[oldUserid];\n\t\t}\n\t}\n\n\trenameRoom(roomid: RoomID) {\n\t\tfor (const player of this.players) {\n\t\t\tconst user = Users.get(player.id);\n\t\t\tuser?.games.delete(this.roomid);\n\t\t\tuser?.games.add(roomid);\n\t\t}\n\t\tthis.roomid = roomid;\n\t}\n\n\t// Commands:\n\n\t// These are all optional to implement:\n\n\t/**\n\t * Called when a user uses /forfeit\n\t * Also planned to be used for some force-forfeit situations, such\n\t * as when a user changes their name and .allowRenames === false\n\t * This is strongly recommended to be supported, as the user is\n\t * extremely unlikely to keep playing after this function is\n\t * called.\n\t */\n\tforfeit?(user: User): void;\n\n\t/**\n\t * Called when a user uses /choose [text]\n\t * If you have buttons, you are recommended to use this interface\n\t * instead of making your own commands.\n\t */\n\tchoose?(user: User, text: string): void;\n\n\t/**\n\t * Called when a user uses /undo [text]\n\t */\n\tundo?(user: User, text: string): void;\n\n\t/**\n\t * Called when a user uses /joingame [text]\n\t */\n\tjoinGame?(user: User, text?: string): void;\n\n\t/**\n\t * Called when a user uses /leavegame [text]\n\t */\n\tleaveGame?(user: User, text?: string): void;\n\n\t// Events:\n\n\t// Note:\n\t// A user can have multiple connections. For instance, if you have\n\t// two tabs open and connected to PS, those tabs represent two\n\t// connections, but a single PS user. Each tab can be in separate\n\t// rooms.\n\n\t/**\n\t * Called when a user joins a room. (i.e. when the user's first\n\t * connection joins)\n\t *\n\t * While connection is passed, it should not usually be used:\n\t * Any handling of connections should happen in onConnect.\n\t */\n\tonJoin(user: User, connection: Connection) {}\n\n\t/**\n\t * Called when a user is banned from the room this game is taking\n\t * place in.\n\t */\n\tremoveBannedUser(user: User) {\n\t\tif (this.forfeit) this.forfeit(user);\n\t}\n\n\t/**\n\t * Called when a user in the game is renamed. `isJoining` is true\n\t * if the user was previously a guest, but now has a username.\n\t * Check `!user.named` for the case where a user previously had a\n\t * username but is now a guest. By default, updates a player's\n\t * name as long as allowRenames is set to true.\n\t */\n\tonRename(user: User, oldUserid: ID, isJoining: boolean, isForceRenamed: boolean) {\n\t\tif (!this.allowRenames || (!user.named && !isForceRenamed)) {\n\t\t\tif (!(user.id in this.playerTable) && !this.isSubGame) {\n\t\t\t\tuser.games.delete(this.roomid);\n\t\t\t\tuser.updateSearch();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!(oldUserid in this.playerTable)) return;\n\t\tif (!user.named) {\n\t\t\treturn this.onLeave(user, oldUserid);\n\t\t}\n\t\tthis.renamePlayer(user, oldUserid);\n\t}\n\n\t/**\n\t * Called when a user leaves the room. (i.e. when the user's last\n\t * connection leaves)\n\t */\n\tonLeave(user: User, oldUserid?: ID) {}\n\n\t/**\n\t * Called each time a connection joins a room (after onJoin if\n\t * applicable). By default, this is also called when connection\n\t * is updated in some way (such as by changing user or renaming).\n\t * If you don't want this behavior, override onUpdateConnection\n\t * and/or onRename.\n\t */\n\tonConnect(user: User, connection: Connection) {}\n\n\t/**\n\t * Called for each connection in a room that changes users by\n\t * merging into a different user. By default, runs the onConnect\n\t * handler.\n\t *\n\t * Player updates and an up-to-date report of what's going on in\n\t * the game should be sent during `onConnect`. You should rarely\n\t * need to handle the other events.\n\t */\n\tonUpdateConnection(user: User, connection: Connection) {\n\t\tthis.onConnect(user, connection);\n\t}\n\n\t/**\n\t * Called for every message a user sends while this game is active.\n\t * Return an error message to prevent the message from being sent,\n\t * an empty string to prevent it with no error message, or\n\t * `undefined` to let it through.\n\t */\n\tonChatMessage(message: string, user: User): string | void {}\n\n\t/**\n\t * Called for every message a user sends while this game is active.\n\t * Unlike onChatMessage, this function runs after the message has been added to the room's log.\n\t * Do not try to use this to block messages, use onChatMessage for that.\n\t */\n\tonLogMessage(message: string, user: User) {}\n}\n\n/**\n * globally Rooms.SimpleRoomGame\n *\n * A RoomGame without a custom player class. Gives a default implementation for makePlayer.\n */\nexport class SimpleRoomGame extends RoomGame<RoomGamePlayer> {\n\tmakePlayer(user: User | string | null, ...rest: any[]): RoomGamePlayer {\n\t\tconst num = this.players.length ? this.players[this.players.length - 1].num : 1;\n\t\treturn new RoomGamePlayer(user, this, num);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBO,MAAM,eAA4D;AAAA,EAkBxE,YAAY,MAA4B,MAAiB,MAAM,GAAG;AACjE,SAAK,MAAM;AACX,QAAI,CAAC;AAAM,aAAO,MAAM,UAAU,QAAQ;AAC1C,SAAK,OAAO;AACZ,SAAK,OAAQ,OAAO,SAAS,WAAW,OAAO,KAAK;AACpD,QAAI,OAAO,SAAS;AAAU,aAAO;AACrC,SAAK,KAAK,OAAO,KAAK,KAAK;AAC3B,QAAI,QAAQ,CAAC,KAAK,KAAK,WAAW;AACjC,WAAK,MAAM,IAAI,KAAK,KAAK,MAAM;AAC/B,WAAK,aAAa;AAAA,IACnB;AAAA,EACD;AAAA,EACA,aAAa;AACZ,QAAI,CAAC,KAAK;AAAI;AACd,UAAM,OAAO,MAAM,SAAS,KAAK,EAAE;AACnC,QAAI,QAAQ,CAAC,KAAK,KAAK,WAAW;AACjC,WAAK,MAAM,OAAO,KAAK,KAAK,MAAM;AAClC,WAAK,aAAa;AAAA,IACnB;AACA,SAAK,KAAK;AAAA,EACX;AAAA,EACA,UAAU;AACT,SAAK,WAAW;AAAA,EACjB;AAAA,EAEA,WAAW;AACV,WAAO,KAAK;AAAA,EACb;AAAA,EACA,KAAK,MAAc;AAClB,UAAM,OAAO,MAAM,SAAS,KAAK,EAAE;AACnC,QAAI;AAAM,WAAK,KAAK,IAAI;AAAA,EACzB;AAAA,EACA,SAAS,MAAc;AACtB,UAAM,OAAO,MAAM,SAAS,KAAK,EAAE;AACnC,QAAI;AAAM,WAAK,OAAO,KAAK,KAAK,QAAQ,IAAI;AAAA,EAC7C;AACD;AAOO,MAAe,SAA8D;AAAA,EA4BnF,YAAY,MAAY,YAAY,OAAO;AAN3C;AAAA,qBAAY;AAOX,SAAK,SAAS,KAAK;AACnB,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,cAAc,uBAAO,OAAO,IAAI;AACrC,SAAK,UAAU,CAAC;AAChB,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,QAAQ;AAEb,QAAI,KAAK,WAAW;AACnB,WAAK,KAAK,UAAU;AAAA,IACrB,OAAO;AACN,WAAK,KAAK,OAAO;AAAA,IAClB;AAAA,EACD;AAAA,EAEA,UAAU;AACT,QAAI,KAAK,WAAW;AACnB,WAAK,KAAK,UAAU;AAAA,IACrB,OAAO;AACN,WAAK,KAAK,OAAO;AAAA,IAClB;AAEA,SAAK,OAAO;AACZ,eAAW,UAAU,KAAK,SAAS;AAClC,aAAO,QAAQ;AAAA,IAChB;AAEA,SAAK,UAAU;AAEf,SAAK,cAAc;AAAA,EACpB;AAAA,EAEA,UAAU,OAA6B,SAAS,MAAiC;AAChF,QAAI,OAAO,SAAS,YAAY,MAAM;AACrC,UAAI,KAAK,MAAM,KAAK;AAAa,eAAO;AAAA,IACzC;AACA,QAAI,KAAK,YAAY,KAAK,KAAK,eAAe,KAAK;AAAW,aAAO;AACrE,UAAM,SAAS,KAAK,WAAW,MAAM,GAAG,IAAI;AAC5C,QAAI,CAAC;AAAQ,aAAO;AACpB,QAAI,OAAO,SAAS;AAAU,aAAO;AACrC,SAAK,QAAQ,KAAK,MAAM;AACxB,QAAI,MAAM;AACT,WAAK,YAAY,KAAK,EAAE,IAAI;AAC5B,WAAK;AAAA,IACN;AACA,WAAO;AAAA,EACR;AAAA,EAEA,aAAa,QAAqB,MAAmB;AACpD,QAAI,CAAC,KAAK;AAAc;AACxB,QAAI,OAAO,IAAI;AACd,aAAO,KAAK,YAAY,OAAO,EAAE;AAAA,IAClC;AACA,QAAI,MAAM;AACT,aAAO,KAAK,KAAK;AACjB,aAAO,OAAO,KAAK;AACnB,WAAK,YAAY,OAAO,EAAE,IAAI;AAC9B,WAAK,KAAK,KAAK,IAAI,KAAK,IAAI,MAAM,aAAa;AAAA,IAChD,OAAO;AACN,aAAO,WAAW;AAAA,IACnB;AAAA,EACD;AAAA,EAIA,aAAa,QAA4B;AACxC,QAAI,kBAAkB,MAAM,MAAM;AAGjC,eAAS,KAAK,YAAY,OAAO,EAAE;AACnC,UAAI,CAAC;AAAQ,cAAM,IAAI,MAAM,kBAAkB;AAAA,IAChD;AACA,QAAI,CAAC,KAAK;AAAc,aAAO;AAC/B,UAAM,cAAc,KAAK,QAAQ,QAAQ,MAAM;AAC/C,QAAI,cAAc;AAAG,aAAO;AAC5B,QAAI,OAAO;AAAI,aAAO,KAAK,YAAY,OAAO,EAAE;AAChD,SAAK,QAAQ,OAAO,aAAa,CAAC;AAClC,WAAO,QAAQ;AACf,SAAK;AACL,WAAO;AAAA,EACR;AAAA,EAEA,aAAa,MAAY,WAAe;AACvC,QAAI,KAAK,OAAO,WAAW;AAC1B,WAAK,YAAY,KAAK,EAAE,EAAE,OAAO,KAAK;AAAA,IACvC,OAAO;AACN,WAAK,YAAY,KAAK,EAAE,IAAI,KAAK,YAAY,SAAS;AACtD,WAAK,YAAY,KAAK,EAAE,EAAE,KAAK,KAAK;AACpC,WAAK,YAAY,KAAK,EAAE,EAAE,OAAO,KAAK;AACtC,aAAO,KAAK,YAAY,SAAS;AAAA,IAClC;AAAA,EACD;AAAA,EAEA,WAAW,QAAgB;AAC1B,eAAW,UAAU,KAAK,SAAS;AAClC,YAAM,OAAO,MAAM,IAAI,OAAO,EAAE;AAChC,YAAM,MAAM,OAAO,KAAK,MAAM;AAC9B,YAAM,MAAM,IAAI,MAAM;AAAA,IACvB;AACA,SAAK,SAAS;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqDA,OAAO,MAAY,YAAwB;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5C,iBAAiB,MAAY;AAC5B,QAAI,KAAK;AAAS,WAAK,QAAQ,IAAI;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,SAAS,MAAY,WAAe,WAAoB,gBAAyB;AAChF,QAAI,CAAC,KAAK,gBAAiB,CAAC,KAAK,SAAS,CAAC,gBAAiB;AAC3D,UAAI,EAAE,KAAK,MAAM,KAAK,gBAAgB,CAAC,KAAK,WAAW;AACtD,aAAK,MAAM,OAAO,KAAK,MAAM;AAC7B,aAAK,aAAa;AAAA,MACnB;AACA;AAAA,IACD;AACA,QAAI,EAAE,aAAa,KAAK;AAAc;AACtC,QAAI,CAAC,KAAK,OAAO;AAChB,aAAO,KAAK,QAAQ,MAAM,SAAS;AAAA,IACpC;AACA,SAAK,aAAa,MAAM,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,MAAY,WAAgB;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASrC,UAAU,MAAY,YAAwB;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/C,mBAAmB,MAAY,YAAwB;AACtD,SAAK,UAAU,MAAM,UAAU;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,SAAiB,MAA2B;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3D,aAAa,SAAiB,MAAY;AAAA,EAAC;AAC5C;AAOO,MAAM,uBAAuB,SAAyB;AAAA,EAC5D,WAAW,SAA+B,MAA6B;AACtE,UAAM,MAAM,KAAK,QAAQ,SAAS,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC,EAAE,MAAM;AAC9E,WAAO,IAAI,eAAe,MAAM,MAAM,GAAG;AAAA,EAC1C;AACD;",
  "names": []
}
