{
  "version": 3,
  "sources": ["../../sim/prng.ts"],
  "sourcesContent": ["/**\n * PRNG\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * This simulates the on-cartridge PRNG used in the real games.\n *\n * In addition to potentially allowing us to read replays from in-game,\n * this also makes it possible to record an \"input log\" (a seed +\n * initial teams + move/switch decisions) and \"replay\" a simulation to\n * get the same result.\n *\n * @license MIT license\n */\n\n/** 64-bit big-endian [high -> low] int */\nexport type PRNGSeed = [number, number, number, number];\n\n/**\n * A PRNG intended to emulate the on-cartridge PRNG for Gen 5 with a 64-bit\n * initial seed.\n */\nexport class PRNG {\n\treadonly initialSeed: PRNGSeed;\n\tseed: PRNGSeed;\n\t/** Creates a new source of randomness for the given seed. */\n\tconstructor(seed: PRNGSeed | null = null) {\n\t\tif (!seed) seed = PRNG.generateSeed();\n\t\tthis.initialSeed = seed.slice() as PRNGSeed; // make a copy\n\t\tthis.seed = seed.slice() as PRNGSeed;\n\t}\n\n\t/**\n\t * Getter to the initial seed.\n\t *\n\t * This should be considered a hack and is only here for backwards compatibility.\n\t */\n\tget startingSeed(): PRNGSeed {\n\t\treturn this.initialSeed;\n\t}\n\n\t/**\n\t * Creates a clone of the current PRNG.\n\t *\n\t * The new PRNG will have its initial seed set to the seed of the current instance.\n\t */\n\tclone(): PRNG {\n\t\treturn new PRNG(this.seed);\n\t}\n\n\t/**\n\t * Retrieves the next random number in the sequence.\n\t * This function has three different results, depending on arguments:\n\t * - random() returns a real number in [0, 1), just like Math.random()\n\t * - random(n) returns an integer in [0, n)\n\t * - random(m, n) returns an integer in [m, n)\n\t * m and n are converted to integers via Math.floor. If the result is NaN, they are ignored.\n\t */\n\tnext(from?: number, to?: number): number {\n\t\tthis.seed = this.nextFrame(this.seed); // Advance the RNG\n\t\tlet result = (this.seed[0] << 16 >>> 0) + this.seed[1]; // Use the upper 32 bits\n\t\tif (from) from = Math.floor(from);\n\t\tif (to) to = Math.floor(to);\n\t\tif (from === undefined) {\n\t\t\tresult = result / 0x100000000;\n\t\t} else if (!to) {\n\t\t\tresult = Math.floor(result * from / 0x100000000);\n\t\t} else {\n\t\t\tresult = Math.floor(result * (to - from) / 0x100000000) + from;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Flip a coin (two-sided die), returning true or false.\n\t *\n\t * This function returns true with probability `P`, where `P = numerator\n\t * / denominator`. This function returns false with probability `1 - P`.\n\t *\n\t * The numerator must be a non-negative integer (`>= 0`).\n\t *\n\t * The denominator must be a positive integer (`> 0`).\n\t */\n\trandomChance(numerator: number, denominator: number): boolean {\n\t\treturn this.next(denominator) < numerator;\n\t}\n\n\t/**\n\t * Return a random item from the given array.\n\t *\n\t * This function chooses items in the array with equal probability.\n\t *\n\t * If there are duplicate items in the array, each duplicate is\n\t * considered separately. For example, sample(['x', 'x', 'y']) returns\n\t * 'x' 67% of the time and 'y' 33% of the time.\n\t *\n\t * The array must contain at least one item.\n\t *\n\t * The array must not be sparse.\n\t */\n\tsample<T>(items: readonly T[]): T {\n\t\tif (items.length === 0) {\n\t\t\tthrow new RangeError(`Cannot sample an empty array`);\n\t\t}\n\t\tconst index = this.next(items.length);\n\t\tconst item = items[index];\n\t\tif (item === undefined && !Object.prototype.hasOwnProperty.call(items, index)) {\n\t\t\tthrow new RangeError(`Cannot sample a sparse array`);\n\t\t}\n\t\treturn item;\n\t}\n\n\t/**\n\t * A Fisher-Yates shuffle. This is how the game resolves speed ties.\n\t *\n\t * At least according to V4 in\n\t * https://github.com/smogon/pokemon-showdown/issues/1157#issuecomment-214454873\n\t */\n\tshuffle<T>(items: T[], start = 0, end: number = items.length) {\n\t\twhile (start < end - 1) {\n\t\t\tconst nextIndex = this.next(start, end);\n\t\t\tif (start !== nextIndex) {\n\t\t\t\t[items[start], items[nextIndex]] = [items[nextIndex], items[start]];\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t}\n\n\t/**\n\t * Calculates `a * b + c` (with 64-bit 2's complement integers)\n\t *\n\t * If you've done long multiplication, this is the same thing.\n\t */\n\tmultiplyAdd(a: PRNGSeed, b: PRNGSeed, c: PRNGSeed) {\n\t\tconst out: PRNGSeed = [0, 0, 0, 0];\n\t\tlet carry = 0;\n\n\t\tfor (let outIndex = 3; outIndex >= 0; outIndex--) {\n\t\t\tfor (let bIndex = outIndex; bIndex < 4; bIndex++) {\n\t\t\t\tconst aIndex = 3 - (bIndex - outIndex);\n\n\t\t\t\tcarry += a[aIndex] * b[bIndex];\n\t\t\t}\n\t\t\tcarry += c[outIndex];\n\n\t\t\tout[outIndex] = carry & 0xFFFF;\n\t\t\tcarry >>>= 16;\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * The RNG is a Linear Congruential Generator (LCG) in the form: `x_{n + 1} = (a x_n + c) % m`\n\t *\n\t * Where: `x_0` is the seed, `x_n` is the random number after n iterations,\n\t *\n\t * ````\n\t * a = 0x5D588B656C078965\n\t * c = 0x00269EC3\n\t * m = 2^64\n\t * ````\n\t */\n\tnextFrame(seed: PRNGSeed, framesToAdvance = 1): PRNGSeed {\n\t\tconst a: PRNGSeed = [0x5D58, 0x8B65, 0x6C07, 0x8965];\n\t\tconst c: PRNGSeed = [0, 0, 0x26, 0x9EC3];\n\n\t\tfor (let i = 0; i < framesToAdvance; i++) {\n\t\t\tseed = this.multiplyAdd(seed, a, c);\n\t\t}\n\n\t\treturn seed;\n\t}\n\n\tstatic generateSeed() {\n\t\treturn [\n\t\t\tMath.floor(Math.random() * 0x10000),\n\t\t\tMath.floor(Math.random() * 0x10000),\n\t\t\tMath.floor(Math.random() * 0x10000),\n\t\t\tMath.floor(Math.random() * 0x10000),\n\t\t] as PRNGSeed;\n\t}\n}\n\n// The following commented-out function is designed to emulate the on-cartridge\n// PRNG for Gens 3 and 4, as described in\n// https://www.smogon.com/ingame/rng/pid_iv_creation#pokemon_random_number_generator\n// This RNG uses a 32-bit initial seed\n// m and n are converted to integers via Math.floor. If the result is NaN, they\n// are ignored.\n/*\nrandom(m: number, n: number) {\n\tthis.seed = (this.seed * 0x41C64E6D + 0x6073) >>> 0; // truncate the result to the last 32 bits\n\tlet result = this.seed >>> 16; // the first 16 bits of the seed are the random value\n\tm = Math.floor(m)\n\tn = Math.floor(n)\n\treturn (m ? (n ? (result % (n - m)) + m : result % m) : result / 0x10000)\n}\n*/\n"],
  "mappings": "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",
  "names": []
}
