{
  "version": 3,
  "sources": ["../../lib/utils.ts"],
  "sourcesContent": ["/**\n * Utils library\n *\n * Miscellaneous utility functions that don't really have a better place.\n *\n * It'll always be a judgment call whether or not a function goes into a\n * \"catch-all\" library like this, so here are some guidelines:\n *\n * - It must not have any dependencies\n *\n * - It must conceivably have a use in a wide variety of projects, not just\n *   Pok\u00E9mon (if it's Pok\u00E9mon-specific, Dex is probably a good place for it)\n *\n * - A lot of Chat functions are kind of iffy, but I'm going to say for now\n *   that if it's English-specific, it should be left out of here.\n */\n\nexport type Comparable = number | string | boolean | Comparable[] | {reverse: Comparable};\n\n/**\n * Safely converts the passed variable into a string. Unlike '' + str,\n * String(str), or str.toString(), Utils.getString is guaranteed not to\n * crash.\n *\n * Specifically, the fear with untrusted JSON is an object like:\n *\n *     let a = {\"toString\": \"this is not a function\"};\n *     console.log(`a is ${a}`);\n *\n * This will crash (because a.toString() is not a function). Instead,\n * getString simply returns '' if the passed variable isn't a\n * string or a number.\n */\n\nexport function getString(str: any): string {\n\treturn (typeof str === 'string' || typeof str === 'number') ? '' + str : '';\n}\n\nexport function escapeRegex(str: string) {\n\treturn str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n\n/**\n * Escapes HTML in a string.\n*/\nexport function escapeHTML(str: string | number) {\n\tif (str === null || str === undefined) return '';\n\treturn ('' + str)\n\t\t.replace(/&/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/>/g, '&gt;')\n\t\t.replace(/\"/g, '&quot;')\n\t\t.replace(/'/g, '&apos;')\n\t\t.replace(/\\//g, '&#x2f;')\n\t\t.replace(/\\n/g, '<br />');\n}\n\n/**\n * Strips HTML from a string.\n */\nexport function stripHTML(htmlContent: string) {\n\tif (!htmlContent) return '';\n\treturn htmlContent.replace(/<[^>]*>/g, '');\n}\n\n/**\n * Maps numbers to their ordinal string.\n */\nexport function formatOrder(place: number) {\n\t// anything between 10 and 20 should always end with -th\n\tlet remainder = place % 100;\n\tif (remainder >= 10 && remainder <= 20) return place + 'th';\n\n\t// follow standard rules with -st, -nd, -rd, and -th\n\tremainder = place % 10;\n\tif (remainder === 1) return place + 'st';\n\tif (remainder === 2) return place + 'nd';\n\tif (remainder === 3) return place + 'rd';\n\treturn place + 'th';\n}\n\n/**\n * Visualizes eval output in a slightly more readable form\n */\nexport function visualize(value: any, depth = 0): string {\n\tif (value === undefined) return `undefined`;\n\tif (value === null) return `null`;\n\tif (typeof value === 'number' || typeof value === 'boolean') {\n\t\treturn `${value}`;\n\t}\n\tif (typeof value === 'string') {\n\t\treturn `\"${value}\"`; // NOT ESCAPED\n\t}\n\tif (typeof value === 'symbol') {\n\t\treturn value.toString();\n\t}\n\tif (Array.isArray(value)) {\n\t\tif (depth > 10) return `[array]`;\n\t\treturn `[` + value.map(elem => visualize(elem, depth + 1)).join(`, `) + `]`;\n\t}\n\tif (value instanceof RegExp || value instanceof Date || value instanceof Function) {\n\t\tif (depth && value instanceof Function) return `Function`;\n\t\treturn `${value}`;\n\t}\n\tlet constructor = '';\n\tif (value.constructor && value.constructor.name && typeof value.constructor.name === 'string') {\n\t\tconstructor = value.constructor.name;\n\t\tif (constructor === 'Object') constructor = '';\n\t} else {\n\t\tconstructor = 'null';\n\t}\n\t// If it has a toString, try to grab the base class from there\n\t// (This is for Map/Set subclasses like user.auth)\n\tconst baseClass = (value?.toString && /\\[object (.*)\\]/.exec(value.toString())?.[1]) || constructor;\n\n\tswitch (baseClass) {\n\tcase 'Map':\n\t\tif (depth > 2) return `Map`;\n\t\tconst mapped = [...value.entries()].map(\n\t\t\tval => `${visualize(val[0], depth + 1)} => ${visualize(val[1], depth + 1)}`\n\t\t);\n\t\treturn `${constructor} (${value.size}) { ${mapped.join(', ')} }`;\n\tcase 'Set':\n\t\tif (depth > 2) return `Set`;\n\t\treturn `${constructor} (${value.size}) { ${[...value].map(v => visualize(v), depth + 1).join(', ')} }`;\n\t}\n\n\tif (value.toString) {\n\t\ttry {\n\t\t\tconst stringValue = value.toString();\n\t\t\tif (typeof stringValue === 'string' &&\n\t\t\t\t\tstringValue !== '[object Object]' &&\n\t\t\t\t\tstringValue !== `[object ${constructor}]`) {\n\t\t\t\treturn `${constructor}(${stringValue})`;\n\t\t\t}\n\t\t} catch {}\n\t}\n\tlet buf = '';\n\tfor (const key in value) {\n\t\tif (!Object.prototype.hasOwnProperty.call(value, key)) continue;\n\t\tif (depth > 2 || (depth && constructor)) {\n\t\t\tbuf = '...';\n\t\t\tbreak;\n\t\t}\n\t\tif (buf) buf += `, `;\n\t\tlet displayedKey = key;\n\t\tif (!/^[A-Za-z0-9_$]+$/.test(key)) displayedKey = JSON.stringify(key);\n\t\tbuf += `${displayedKey}: ` + visualize(value[key], depth + 1);\n\t}\n\tif (constructor && !buf && constructor !== 'null') return constructor;\n\treturn `${constructor}{${buf}}`;\n}\n\n/**\n * Compares two variables; intended to be used as a smarter comparator.\n * The two variables must be the same type (TypeScript will not check this).\n *\n * - Numbers are sorted low-to-high, use `-val` to reverse\n * - Strings are sorted A to Z case-semi-insensitively, use `{reverse: val}` to reverse\n * - Booleans are sorted true-first (REVERSE of casting to numbers), use `!val` to reverse\n * - Arrays are sorted lexically in the order of their elements\n *\n * In other words: `[num, str]` will be sorted A to Z, `[num, {reverse: str}]` will be sorted Z to A.\n */\nexport function compare(a: Comparable, b: Comparable): number {\n\tif (typeof a === 'number') {\n\t\treturn a - (b as number);\n\t}\n\tif (typeof a === 'string') {\n\t\treturn a.localeCompare(b as string);\n\t}\n\tif (typeof a === 'boolean') {\n\t\treturn (a ? 1 : 2) - (b ? 1 : 2);\n\t}\n\tif (Array.isArray(a)) {\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tconst comparison = compare(a[i], (b as Comparable[])[i]);\n\t\t\tif (comparison) return comparison;\n\t\t}\n\t\treturn 0;\n\t}\n\tif ('reverse' in a) {\n\t\treturn compare((b as {reverse: string}).reverse, a.reverse);\n\t}\n\tthrow new Error(`Passed value ${a} is not comparable`);\n}\n\n/**\n * Sorts an array according to the callback's output on its elements.\n *\n * The callback's output is compared according to `PSUtils.compare`\n * (numbers low to high, strings A-Z, booleans true-first, arrays in order).\n */\nexport function sortBy<T>(array: T[], callback: (a: T) => Comparable): T[];\n/**\n * Sorts an array according to `PSUtils.compare`\n * (numbers low to high, strings A-Z, booleans true-first, arrays in order).\n *\n * Note that array.sort() only works on strings, not numbers, so you'll need\n * this to sort numbers.\n */\nexport function sortBy<T extends Comparable>(array: T[]): T[];\nexport function sortBy<T>(array: T[], callback?: (a: T) => Comparable) {\n\tif (!callback) return (array as any[]).sort(compare);\n\treturn array.sort((a, b) => compare(callback(a), callback(b)));\n}\n\nexport function splitFirst(str: string, delimiter: string): [string, string];\nexport function splitFirst(str: string, delimiter: string, limit: 2): [string, string, string];\nexport function splitFirst(str: string, delimiter: string, limit: 3): [string, string, string, string];\nexport function splitFirst(str: string, delimiter: string, limit: number): string[];\n/**\n* Like string.split(delimiter), but only recognizes the first `limit`\n* delimiters (default 1).\n*\n* `\"1 2 3 4\".split(\" \", 2) => [\"1\", \"2\"]`\n*\n* `Utils.splitFirst(\"1 2 3 4\", \" \", 1) => [\"1\", \"2 3 4\"]`\n*\n* Returns an array of length exactly limit + 1.\n*\n*/\nexport function splitFirst(str: string, delimiter: string, limit = 1) {\n\tconst splitStr: string[] = [];\n\twhile (splitStr.length < limit) {\n\t\tconst delimiterIndex = str.indexOf(delimiter);\n\t\tif (delimiterIndex >= 0) {\n\t\t\tsplitStr.push(str.slice(0, delimiterIndex));\n\t\t\tstr = str.slice(delimiterIndex + delimiter.length);\n\t\t} else {\n\t\t\tsplitStr.push(str);\n\t\t\tstr = '';\n\t\t}\n\t}\n\tsplitStr.push(str);\n\treturn splitStr;\n}\n\n/**\n * Template string tag function for escaping HTML\n */\nexport function html(strings: TemplateStringsArray, ...args: any) {\n\tlet buf = strings[0];\n\tlet i = 0;\n\twhile (i < args.length) {\n\t\tbuf += escapeHTML(args[i]);\n\t\tbuf += strings[++i];\n\t}\n\treturn buf;\n}\n\n/**\n * This combines escapeHTML and forceWrap. The combination allows us to use\n * <wbr /> instead of U+200B, which will make sure the word-wrapping hints\n * can't be copy/pasted (which would mess up code).\n */\nexport function escapeHTMLForceWrap(text: string): string {\n\treturn escapeHTML(forceWrap(text)).replace(/\\u200B/g, '<wbr />');\n}\n\n/**\n * HTML doesn't support `word-wrap: break-word` in tables, but sometimes it\n * would be really nice if it did. This emulates `word-wrap: break-word` by\n * manually inserting U+200B to tell long words to wrap.\n */\nexport function forceWrap(text: string): string {\n\treturn text.replace(/[^\\s]{30,}/g, word => {\n\t\tlet lastBreak = 0;\n\t\tlet brokenWord = '';\n\t\tfor (let i = 1; i < word.length; i++) {\n\t\t\tif (i - lastBreak >= 10 || /[^a-zA-Z0-9([{][a-zA-Z0-9]/.test(word.slice(i - 1, i + 1))) {\n\t\t\t\tbrokenWord += word.slice(lastBreak, i) + '\\u200B';\n\t\t\t\tlastBreak = i;\n\t\t\t}\n\t\t}\n\t\tbrokenWord += word.slice(lastBreak);\n\t\treturn brokenWord;\n\t});\n}\n\nexport function shuffle<T>(arr: T[]): T[] {\n\t// In-place shuffle by Fisher-Yates algorithm\n\tfor (let i = arr.length - 1; i > 0; i--) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[arr[i], arr[j]] = [arr[j], arr[i]];\n\t}\n\treturn arr;\n}\n\nexport function randomElement<T>(arr: T[]): T {\n\tconst i = Math.floor(Math.random() * arr.length);\n\treturn arr[i];\n}\n\n/** Forces num to be an integer (between min and max). */\nexport function clampIntRange(num: any, min?: number, max?: number): number {\n\tif (typeof num !== 'number') num = 0;\n\tnum = Math.floor(num);\n\tif (min !== undefined && num < min) num = min;\n\tif (max !== undefined && num > max) num = max;\n\treturn num;\n}\n\nexport function clearRequireCache(options: {exclude?: string[]} = {}) {\n\tconst excludes = options?.exclude || [];\n\texcludes.push('/node_modules/');\n\n\tfor (const path in require.cache) {\n\t\tlet skip = false;\n\t\tfor (const exclude of excludes) {\n\t\t\tif (path.includes(exclude)) {\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!skip) delete require.cache[path];\n\t}\n}\n\nexport function deepClone(obj: any): any {\n\tif (obj === null || typeof obj !== 'object') return obj;\n\tif (Array.isArray(obj)) return obj.map(prop => deepClone(prop));\n\tconst clone = Object.create(Object.getPrototypeOf(obj));\n\tfor (const key of Object.keys(obj)) {\n\t\tclone[key] = deepClone(obj[key]);\n\t}\n\treturn clone;\n}\n\nexport function levenshtein(s: string, t: string, l: number): number {\n\t// Original levenshtein distance function by James Westgate, turned out to be the fastest\n\tconst d: number[][] = [];\n\n\t// Step 1\n\tconst n = s.length;\n\tconst m = t.length;\n\n\tif (n === 0) return m;\n\tif (m === 0) return n;\n\tif (l && Math.abs(m - n) > l) return Math.abs(m - n);\n\n\t// Create an array of arrays in javascript (a descending loop is quicker)\n\tfor (let i = n; i >= 0; i--) d[i] = [];\n\n\t// Step 2\n\tfor (let i = n; i >= 0; i--) d[i][0] = i;\n\tfor (let j = m; j >= 0; j--) d[0][j] = j;\n\n\t// Step 3\n\tfor (let i = 1; i <= n; i++) {\n\t\tconst si = s.charAt(i - 1);\n\n\t\t// Step 4\n\t\tfor (let j = 1; j <= m; j++) {\n\t\t\t// Check the jagged ld total so far\n\t\t\tif (i === j && d[i][j] > 4) return n;\n\n\t\t\tconst tj = t.charAt(j - 1);\n\t\t\tconst cost = (si === tj) ? 0 : 1; // Step 5\n\n\t\t\t// Calculate the minimum\n\t\t\tlet mi = d[i - 1][j] + 1;\n\t\t\tconst b = d[i][j - 1] + 1;\n\t\t\tconst c = d[i - 1][j - 1] + cost;\n\n\t\t\tif (b < mi) mi = b;\n\t\t\tif (c < mi) mi = c;\n\n\t\t\td[i][j] = mi; // Step 6\n\t\t}\n\t}\n\n\t// Step 7\n\treturn d[n][m];\n}\n\nexport function waitUntil(time: number): Promise<void> {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(() => resolve(), time - Date.now());\n\t});\n}\n\n/** Like parseInt, but returns NaN if the int isn't already in normalized form */\nexport function parseExactInt(str: string): number {\n\tif (!/^-?(0|[1-9][0-9]*)$/.test(str)) return NaN;\n\treturn parseInt(str);\n}\n\n/** formats an array into a series of question marks and adds the elements to an arguments array */\nexport function formatSQLArray(arr: unknown[], args?: unknown[]) {\n\targs?.push(...arr);\n\treturn [...'?'.repeat(arr.length)].join(', ');\n}\n\nexport class Multiset<T> extends Map<T, number> {\n\tadd(key: T) {\n\t\tthis.set(key, (this.get(key) ?? 0) + 1);\n\t\treturn this;\n\t}\n\tremove(key: T) {\n\t\tconst newValue = (this.get(key) ?? 0) - 1;\n\t\tif (newValue <= 0) return this.delete(key);\n\t\tthis.set(key, newValue);\n\t\treturn true;\n\t}\n}\n\n// backwards compatibility\nexport const Utils = {\n\tparseExactInt, waitUntil, html, escapeHTML,\n\tcompare, sortBy, levenshtein,\n\tshuffle, deepClone, clearRequireCache,\n\trandomElement, forceWrap, splitFirst,\n\tstripHTML, visualize, getString,\n\tescapeRegex, formatSQLArray, Multiset,\n};\n"],
  "mappings": "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",
  "names": []
}
